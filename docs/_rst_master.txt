# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\bible.rst
Style Rules
==================

The guidelines below are the compass for our coding journey. Adhere to them, and the path to clean and readable code shall be illuminated.

Module Names
------------
- Lowercase with underscores as necessary to improve readability: `my_module.py`.

Package Names
-------------
- All lowercase, no underscores needed: `mypackage`.

Class Names
-----------
- CamelCase, capitalizing the first letter of each word: `MyClass`.

Function Names
--------------
- Lowercase with underscores separating words: `my_function()`.

Constant Names
--------------
- All caps with underscores separating words: `MY_CONSTANT`.

Variable Names
--------------
- Lowercase with underscores separating words: `my_variable`.

Indentation
-----------
- Use 4 spaces per indentation level. Consistency is key.

Line Length
-----------
- Keep each line to a maximum of 79 characters.

Imports
-------
- Group your imports in the following order: standard library imports, related third-party imports, local application/library specific imports. Add a blank line between each group.

Whitespace
----------
- Keep it cleanâ€”no trailing whitespace and use spacing around operators and after commas to improve readability.

File and Directory Naming
=========================

- **Files**: Use lowercase with underscores as necessary. For example, `my_script.py` or `my_module.py`.
- **Directories**: Use lowercase without underscores for package directories. For non-package directories, you can use underscores if it improves readability. For example, `mypackage` and `my_directory`.

Files should be named after the module they contain. A Python file called `my_module.py` would correspond to a module named `my_module`.

Directories that are Python packages (those containing an `__init__.py` file) should also be named in lowercase, without underscores, to align with package naming conventions. Non-package directories, such as those containing resources or documentation, can use underscores if it improves readability.

Remember, the goal is to keep names descriptive yet concise. They should give a clue about the content and purpose, without getting too lengthy.

Examples:
- Correct: `instrument/oscilloscope/controls/`
- Avoid: `Instrument/Oscilloscope_Controls/`

File Names
----------
- Use lowercase, and if it's a Python script, give it a `.py` extension. If the file is a module that will be imported, underscores can be used for readability: `useful_functions.py`.
- For executable scripts, keep it short and sweet, avoid underscores if possible: `manage`.

Directory Names
---------------
- Keep directory names lowercase and avoid using underscores unless it improves readability.
- Directories that are packages (i.e., contain an `__init__.py` file) should follow package naming conventions: `mypackage`.
- Non-package directories, like those for documentation, static files, or configuration, can use hyphens to improve readability: `config-files`, `static-assets`.
# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\bible.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\design.rst
Subsystem Practical Coding Example
==================================

This section provides a concrete example of how to create a subsystem within the library, using the waveform subsystem of an oscilloscope as a case study. It highlights the use of properties with getters and setters to keep the software model and the physical instrument state synchronized.

Subsystem Synchronization
-------------------------

The library employs property decorators to define getters and setters for instrument parameters, facilitating the real-time synchronization of the software model with the instrument's actual settings. This synchronization ensures that changes to parameters within the software are immediately reflected in the instrument's configuration, allowing for robust error handling and prompt feedback.

**Getters and Setters:**

- **Getters**: Retrieve the current value of an instrument setting directly from the hardware, ensuring that the software's state is always up-to-date.
- **Setters**: Send updated values to the instrument whenever a property is assigned a new value, followed by querying the instrument to validate the change.

These mechanisms ensure that the instrument's object model within the software and its physical state remain aligned, providing a reliable and consistent interface for users.

Creating the Waveform Subsystem
-------------------------------

The waveform subsystem controls waveform settings on the oscilloscope. It demonstrates how to encapsulate SCPI commands for setting and querying waveform parameters, such as points, points mode, and format.

.. code-block:: python
   :caption: Waveform Subsystem Example
   :name: waveform-subsystem-example

   class WaveformSubsystem(InstrumentSubsystem):
       """A class to represent the waveform subsystem of an oscilloscope."""
       
       def __init__(self, parent):
           super().__init__(parent)
           self._points = None
           self._points_mode = None
           self._format = None

       @property
       def points(self):
           """Gets/sets the number of points in the waveform."""
           if self._points is None:
               self._points = int(self._parent.query(":WAVEFORM:POINTS?"))
           return self._points

       @points.setter
       def points(self, value):
           self._parent.write(f":WAVEFORM:POINTS {value}")
           self._points = value  # Synchronize the software model with the instrument

       @property
       def points_mode(self):
           """Gets/sets the points mode of the waveform."""
           if self._points_mode is None:
               self._points_mode = self._parent.query(":WAVEFORM:POINTS:MODE?")
           return self._points_mode

       @points_mode.setter
       def points_mode(self, value):
           self._parent.write(f":WAVEFORM:POINTS:MODE {value}")
           self._points_mode = value  # Synchronize the software model with the instrument

       @property
       def format(self):
           """Gets/sets the format of the waveform data."""
           if self._format is None:
               self._format = self._parent.query(":WAVEFORM:FORMAT?")
           return self._format

       @format.setter
       def format(self, value):
           self._parent.write(f":WAVEFORM:FORMAT {value}")
           self._format = value  # Synchronize the software model with the instrument

       def sync(self):
           """Synchronizes the subsystem with the current instrument settings."""
           self._points = None
           self._points_mode = None
           self._format = None
           # This forces the properties to re-query the instrument when next accessed

Using the Waveform Subsystem
----------------------------

With the waveform subsystem defined, users can interact with the oscilloscope's waveform settings intuitively:

.. code-block:: python
   :caption: Using the Waveform Subsystem
   :name: using-waveform-subsystem

   oscilloscope = Oscilloscope('GPIB::ADDRESS')
   oscilloscope.open()

   # Configure the waveform settings
   oscilloscope.waveform.points = 1200
   oscilloscope.waveform.points_mode = 'MAX'
   oscilloscope.waveform.format = 'ASC'

   # Retrieve and print the current waveform settings
   print(f"Waveform Points: {oscilloscope.waveform.points}")
   print(f"Waveform Points Mode: {oscilloscope.waveform.points_mode}")
   print(f"Waveform Format: {oscilloscope.waveform.format}")

This example demonstrates how to encapsulate the control and querying of instrument settings within a subsystem, providing a clear and straightforward interface for users. The use of property decorators for getters and setters not only simplifies the command structure but also ensures that the software model remains in sync with the physical state of the instrument, enhancing usability and reliability.

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\design.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\doc-build.rst
Rebuilding the Documentation
============================

This guide will walk you through setting up Sphinx for generating project documentation, installing Graphviz for creating diagrams, and using the Read the Docs theme for a clean, professional look.

Installing Sphinx
-----------------

To install Sphinx, you will need Python installed on your system. Python 3.6 or higher is recommended. You can install Sphinx using pip:

.. code-block:: bash

    pip install sphinx

Installing Graphviz
-------------------

Graphviz is an open-source graph visualization software used to create diagrams in Sphinx via the Graphviz extension. Install it from your operating system's package manager or the Graphviz download page:

- For Windows, download the installer from `Graphviz Download <https://graphviz.org/download/>`_.
- For macOS, use Homebrew:

  .. code-block:: bash

      brew install graphviz

- For Linux (Debian/Ubuntu):

  .. code-block:: bash

      sudo apt-get install graphviz

Installing Read the Docs Sphinx Theme
-------------------------------------

The Read the Docs theme can be installed via pip:

.. code-block:: bash

    pip install sphinx_rtd_theme

Installing Sphinx Graphviz Extension
------------------------------------

The Sphinx Graphviz extension should be included with Sphinx by default. If you need to install it separately, you can do so using pip:

.. code-block:: bash

    pip install sphinxcontrib-plantuml sphinxcontrib-actdiag sphinxcontrib-blockdiag sphinxcontrib-nwdiag sphinxcontrib-seqdiag

Setting Up `conf.py`
--------------------

Your `conf.py` file is where you configure your Sphinx documentation build. Here's a basic setup:

.. code-block:: python

    import os
    import sys
    sys.path.insert(0, os.path.abspath('../..'))  # Adjust the path to the root of your project

    project = 'Your Project'
    author = 'Your Name'

    extensions = [
        'sphinx.ext.autodoc',
        'sphinx.ext.graphviz',
        'sphinx_rtd_theme',
    ]

    html_theme = 'sphinx_rtd_theme'
    html_static_path = ['_static']

    graphviz_output_format = 'png'

Building Your Documentation
---------------------------

To build your documentation, navigate to your documentation directory and run:

.. code-block:: bash

    make html

This command will generate HTML documentation in the `_build/html` directory.

Creating Your First Page
------------------------

Start by creating an `index.rst` file in your documentation source directory with the following content:

.. code-block:: rst

    Welcome to My Project Documentation
    ===================================

    .. toctree::
       :maxdepth: 2
       :caption: Contents:

       introduction
       getting_started
       api_reference

Replace `introduction`, `getting_started`, and `api_reference` with the actual names of your `.rst` or `.md` files.

Adding Diagrams with Graphviz
-----------------------------

You can add diagrams to your `.rst` files using the Graphviz directive:

.. code-block:: rst

    .. graphviz::

       digraph example {
           A -> B;
           B -> C;
           C -> D;
       }

This simple directive will create a diagram showing nodes A, B, C, and D with directed edges between them as shown below.

.. graphviz::

       digraph example {
           A -> B;
           B -> C;
           C -> D;
       }

Conclusion
----------

You now have a basic Sphinx setup with support for Graphviz diagrams and a professional theme from Read the Docs. Modify the `conf.py` settings and `.rst` files to suit your project's documentation needs.

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\doc-build.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\factories.rst
Leveraging Command Parameters and Options for Efficient Instrument Control
===========================================================================

The `pymetr` library introduces an efficient, streamlined approach to instrument control, significantly reducing the complexity traditionally associated with direct device communication. Through the innovative use of factory functions `command_property` and `command_options`, `pymetr` enables developers to define instrument properties with minimal code, enhancing maintainability, readability, and error handling.

Simplifying Property Synchronization
-------------------------------------

Traditionally, interfacing with instruments involves verbose getters and setters to synchronize object properties with instrument states. This method, while effective, results in extensive boilerplate code, increasing the likelihood of errors and complicating code maintenance.

Consider this conventional approach:

.. code-block:: python

    from enum import Enum

    class Acquire:
        class Type(Enum):
            NORMAL = "NORM"
            AVERAGE = "AVER"

        def __init__(self, parent):
            self._parent = parent
            self._type = None
            self._depth = None

        @property
        def type(self):
            response = self._parent.query(":ACQuire:TYPE?")
            self._type = self.Type(response.strip())
            return self._type

        @type.setter
        def type(self, value):
            if isinstance(value, self.Type):
                self._parent.write(f":ACQuire:TYPE {value.value}")
                self._type = value
            else:
                raise ValueError("Invalid acquisition type")

        # Similar code for 'depth' property

This example, while functional, involves a lot of repetitive code for defining each property, significantly bloating the class definition.

Introducing `command_property` and `command_options`
-----------------------------------------------------

`command_property` and `command_options` factory functions dramatically simplify property definition. `command_property` allows for the creation of properties with integrated getters and setters, tailored to specific instrument commands. `command_options` facilitates the definition of valid command parameters, enforcing valid values through enums.

Refactoring the Acquire Subsystem
----------------------------------

Using `command_property` and `command_options`, we can refactor the `Acquire` subsystem to achieve the same functionality with less code and improved readability:

.. code-block:: python

    from pymetr.instruments import Subsystem, command_property, command_options

    class Acquire(InstrumentSubsystem):
        Type = command_options('Type', ['NORMAL', 'AVERAGE', 'HRES', 'PEAK'])
        type = command_property(":TYPE", Type, "Type of acquisition.")
        mode = command_property(":MODE", Mode, "Current acquisition mode.")
        
        def __init__(self, parent):
            super().__init__(parent, cmd_prefix=":ACQuire")

This refactor significantly reduces the amount of boilerplate code, making the class definition cleaner and more maintainable. The `cmd_prefix` initialization parameter further streamlines command construction, eliminating the need to repeat the command prefix for each property.

Conclusion
----------

By adopting `command_property` and `command_options`, `pymetr` offers a more efficient and error-resistant method for developing instrument control interfaces. This approach not only simplifies property definition but also ensures type safety and reduces the potential for bugs, making instrument control software development more accessible and maintainable.


# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\factories.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\index.rst
PyMetr Documentation
==========================

Purpose
-------
This project empowers engineers to craft their own test routines and software, streamlining design verification automation. By providing a pristine example platform, it serves as the seed for future development, offering a crystalline foundation from which test scripts and virtual front panels for a variety of test equipment can be built.

Todo
----

- Standardize enumeration string format across subsystems.
- Add doc-strings to subsystem enum types explaining operation modes.
- Standardize doc-strings format away from the sphinx style parameters.
- Create subsystems.py to manage all subystems and refactor.
- Update subsystem abstract base class and allowed instrument subsystem calls.
- Documentation graphics and hyper-links.
- Start spectrum analyzer class.
- Start power meter class.
- Get package published. 
- Rework GUI controls.
- Refactor Oscilloscope GUI acquisition thread.

System Dependencies
-------------------
- **Python Version**: 3.12.0
- **pyvisa**: Instrument communication
- **pyside6**: Qt bindings and GUI application development
- **numpy**: Efficient numerical computations
- **vispy**: High-performance graphics

.. toctree::
   :maxdepth: 2
   :caption: Contents:
   
   quickstart
   instruments
   subsystems
   subsystem_theory
   factories
   design
   oscilloscope
   packaging
   doc-build
   sphinx
   bible
   logging
   unit-test

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\index.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\instruments.rst
Instrument Control Library
==========================

The ``Instruments Library`` is engineered as the foundational framework for interfacing and commanding a wide range of test and measurement devices. At the core of this framework is the ``Instrument`` base class, which interfaces with the PyVISA library to support various communication protocols and instrument-specific operations.

Instrument Base Class
---------------------

The ``Instrument`` base class unifies the API for interacting with instruments of diverse nature. It utilizes PyVISA as the backend for communication, covering standard protocols such as GPIB, RS232, USB, and Ethernet. It is designed to be extended for custom interfaces and communication protocols.

**Key Features:**

- Standardized management of connections (open/close).
- Execution of SCPI-compliant and customized commands (read/write).
- Immediate query execution with built-in response processing.
- Reliable instrument identification and status management.

Class Diagram
-------------

The class diagram illustrates the relationship between the PyVISA backend and the ``Instrument`` class. It highlights how the ``Instrument`` class extends PyVISA's functionality with additional methods for controlling measurement devices.

.. graphviz::

   digraph architecture {
      node [shape=record, fontname=Helvetica, fontsize=10];
      
      PyVISA [label="{PyVISA|+ open_resource()\l+ list_resources()\l+ read()\l+ write()\l...}"]
      Instrument [label="{Instrument|+ identity(): str\l+ status(): str\l+ reset()\l+ clear_status()\l...}"]

      PyVISA -> Instrument [arrowhead="onormal", style="dashed"]

      label="Instrument Class Architecture";
      fontsize=12;
   }

Utilizing the Library
---------------------

Below is a succinct example illustrating the application of the library within a Python script for fundamental instrument interaction:

.. code-block:: python

   from pymetr.instrument import Instrument

   # Instrument discovery and selection
   instrument_address = Instrument.select_resources()
   my_instrument = Instrument(instrument_address)
   my_instrument.open()

   # Engaging with the instrument
   print(my_instrument.identity())
   print(my_instrument.query('MEAS:VOLT:DC?'))

Instrument Class API
--------------------

.. autoclass:: pymetr.instrument.Instrument
   :members:
   :undoc-members:
   :show-inheritance:

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\instruments.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\logging.rst
Logging in Python Projects
==========================

Logging is a powerful way to track events that happen while software runs. The Python ``logging`` module provides a standard way for applications to log messages in different severity levels (debug, info, warning, error, and critical).

Setting Up Logging
------------------

To set up logging in a Python project, you should configure the logging system using the ``logging.basicConfig()`` function. This configuration is global and affects all loggers within the application.

.. code-block:: python

    import logging

    logging.basicConfig(level=logging.DEBUG,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

The ``basicConfig`` function has several parameters to customize logging:

- ``level``: The root logger will be set to the specified severity level.
- ``format``: This is the format of the log message.

Logger Hierarchy and Effective Level
------------------------------------

The Python logging module uses a hierarchical structure of loggers with a root logger at the top. Each logger can have multiple handlers, which can propagate messages up the hierarchy.

The effective logging level of a logger is the first level set on the logger or its ancestors up to the root.

Creating and Using Loggers
--------------------------

Create a logger in each module to log messages. The logger name is usually the module's name, represented by ``__name__``.

.. code-block:: python

    logger = logging.getLogger(__name__)

You can then use the logger to log messages at different severity levels:

.. code-block:: python

    logger.debug("Debugging information")
    logger.info("Informational message")
    logger.warning("Warning: configuration file not found")
    logger.error("Error occurred")
    logger.critical("Critical error -- shutting down")

Logging Best Practices
----------------------

- **Use Module-Level Loggers**: Create a logger in each module with ``logger = logging.getLogger(__name__)``.
- **Log at Appropriate Levels**: Choose the appropriate logging level for each message to make the log output more useful.
- **Configure Logging at Application Entry Point**: Set up logging configuration (e.g., in the main script or Jupyter notebook) to control logging behavior globally.
- **Use Loggers Hierarchically**: Take advantage of the logging hierarchy to control logging more granularly in large applications.

Further Reading
---------------

- Official Python Logging Documentation: https://docs.python.org/3/library/logging.html
- Logging Cookbook: https://docs.python.org/3/howto/logging-cookbook.html
- Logging Handlers: https://docs.python.org/3/library/logging.handlers.html

The Python ``logging`` module is versatile and can be customized extensively to suit the needs of small to large applications. Proper use of logging can greatly enhance the maintainability and debuggability of an application.


# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\logging.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\oscilloscope.rst
Oscilloscope Extension
======================

The ``Oscilloscope`` class serves as an orchestrator for the complex interplay of its various subsystems, each encapsulated within its own class. Unlike a classical inheritance structure, the ``Oscilloscope`` class does not serve as a superclass from which subsystems inherit. Instead, it aggregates these subsystemsâ€”such as ``Trigger``, ``Timebase``, ``Waveform``, ``WaveGen``, ``Acquire``, and ``Channel``â€”as components, illustrating a composition-based architecture.

This design philosophy allows for a high degree of modularity, enabling each subsystem to be developed, tested, and modified independently while the ``Oscilloscope`` class provides a cohesive and unified interface for the user. The result is a robust and scalable structure, where the complexity of the instrument's functionalities is managed with grace and precision.

The ``pymetr`` package reflects this architecture, segregating related functionalities into dedicated subsystem classes. This not only enhances code organization but also fosters intuitive and object-oriented control over each aspect of the oscilloscope. Below is a visual representation of the ``Oscilloscope`` class composition:

.. graphviz::

   digraph architecture {
      node [shape=record fontname=Helvetica fontsize=10];
      rankdir=UD;
      
      InstrumentInterface [label="{InstrumentInterface|+ open()\l+ close()\l+ write(command: str)\l+ read(): str\l+ query(command: str): str\l}"];
      
      Instrument [label="{Instrument|+ identity()\l+ reset()\l+ status()\l}"];
      Oscilloscope [label="{Oscilloscope|+ run()\l+ stop()\l+ single()\l+ autoscale()\l}"];
      
      Acquire [label="{Acquire|+ sync()\l+ _mode: Mode\l+ _type: Type\l}"];
      Channel [label="{Channel|+ sync()\l+ coupling: Coupling\l+ display: DisplayState\l}"];
      Timebase [label="{Timebase|+ sync()\l+ mode: Mode\l+ position: float\l}"];
      Trigger [label="{Trigger|+ sync()\l+ mode: Mode\l+ level: float\l}"];
      Waveform [label="{Waveform|+ sync()\l+ format: Format\l+ source: Source\l}"];
      WaveGen [label="{WaveGen|+ sync()\l+ function: Function\l+ output: OutputState\l}"];
      
      InstrumentInterface -> Instrument [arrowhead="onormal", style="dashed"];
      Instrument -> Oscilloscope [arrowhead="onormal", style="dashed"];
      
      Oscilloscope -> Acquire [arrowhead="odiamond"];
      Oscilloscope -> Channel [arrowhead="odiamond"];
      Oscilloscope -> Timebase [arrowhead="odiamond"];
      Oscilloscope -> Trigger [arrowhead="odiamond"];
      Oscilloscope -> Waveform [arrowhead="odiamond"];
      Oscilloscope -> WaveGen [arrowhead="odiamond"];
      
      {rank=same; Acquire Channel Timebase Trigger Waveform WaveGen}
   }


Oscilloscope Core
-----------------

.. automodule:: pymetr.oscilloscope.Oscilloscope
   :members:
   :undoc-members:
   :show-inheritance:

Oscilloscope Subsystems
-----------------------

The subsystems are instantiated within the ``Oscilloscope`` class and are accessed through the corresponding attributes.
Each subsystem class focuses on a specific area of oscilloscope functionality, providing specialized methods and properties for that domain.

Acquire Subsystem
-----------------

.. automodule:: pymetr.subsystems.acquire
   :members:
   :undoc-members:
   :show-inheritance:

The ``Acquire`` subsystem manages data acquisition settings, offering control over how the oscilloscope captures and processes the signal data.

Channel Subsystem
-----------------

.. automodule:: pymetr.subsystems.channel
   :members:
   :undoc-members:
   :show-inheritance:

Each channel of the oscilloscope is represented by a ``Channel`` object, allowing individual control over display, scaling, and other channel-specific settings.

Timebase Subsystem
------------------

.. automodule:: pymetr.subsystems.timebase
   :members:
   :undoc-members:
   :show-inheritance:

The ``Timebase`` subsystem governs the horizontal sweep of the oscilloscope, dictating the scale and position of the waveform in time.

Trigger Subsystem
-----------------

.. automodule:: pymetr.subsystems.trigger
   :members:
   :undoc-members:
   :show-inheritance:

Trigger settings are crucial for accurate waveform capture. The ``Trigger`` subsystem provides precise control over when the oscilloscope starts acquiring data.

Waveform Subsystem
------------------

.. automodule:: pymetr.subsystems.waveform
   :members:
   :undoc-members:
   :show-inheritance:

After acquisition, the ``Waveform`` subsystem takes over, dealing with waveform data retrieval and analysis.

WaveGen Subsystem
-----------------

.. automodule:: pymetr.subsystems.wavegen
   :members:
   :undoc-members:
   :show-inheritance:

Some oscilloscopes come with a built-in waveform generator. The ``WaveGen`` subsystem manages this feature, controlling waveform output and modulation.


Root-Level Functions
====================

Beyond the subsystems, the ``Oscilloscope`` class includes root-level functions. These include functions like `run`, `stop`, `single`, and `autoscale`.

.. note:: The ``Oscilloscope`` class is designed with the user in mind, abstracting the complexities of the oscilloscope operation and providing a user-friendly interface that reflects the natural workflow of an engineer or technician working with the instrument.

Getting Started with the Oscilloscope Class
-------------------------------------------

To begin using the ``Oscilloscope`` class, first ensure that PyVISA is installed and properly configured in your environment. Here's a quick rundown on creating an instance of the ``Oscilloscope`` and running basic operations:

.. code-block:: python

   from pymetr.oscilloscope import Oscilloscope

   # Replace with your oscilloscope's VISA resource string
   resource_string = 'TCPIP0::192.168.1.111::hislip0::INSTR'
   osc = Oscilloscope(resource_string)
   osc.open()
   print(f"Identification string: '{osc.identity()}'")
   osc.close()

Extending the Oscilloscope Class
---------------------------------

Some specific models of osilloscopes may have subsystems or settings which differ from the Keysight DSOX1204G. That this class can be used as a base class to create specific models of oscilloscopes.

.. code-block:: python

   from pymetr.oscilloscope.core import Oscilloscope

   Class oscilloscope_XYZ(Oscilloscope):
      # Continue example code

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\oscilloscope.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\packaging.rst
====================================
Installing the pymetr Package
====================================

The pymetr package is designed to facilitate advanced instrumentation capabilities in Python, including oscilloscope controls and data acquisition tools. This document outlines how to install the pymetr package, either for development purposes or for use in other projects.

Setup.py File
-------------

The `setup.py` file is the build script for setuptools. It tells setuptools about your package (such as the name and version) as well as which code files to include. An example `setup.py` file for pymetr might look like this:

.. code-block:: python

   from setuptools import setup, find_packages

   setup(
       name='pymetr',
       version='0.1.0',
       packages=find_packages(),
       description='Python Instrumentation Package',
       long_description=open('README.md').read(),
       author='Your Name',
       author_email='your.email@example.com',
       url='https://github.com/yourusername/pymetr',
       license='MIT',
       install_requires=[
           'numpy',
           'PySide6',
           'vispy',
           # Add other dependencies here
       ],
   )

This script is executed to install your package. The `find_packages()` function automatically discovers all packages and subpackages. In the `install_requires` list, you should specify any third-party dependencies your package needs.

Installing the Package
----------------------

There are two main scenarios for installing the pymetr package:

1. **Installing for Use in Projects**: If you wish to use pymetr as a dependency in other projects, you can install it from your local copy or from a Git repository.

   To install a local copy directly:

   .. code-block:: bash

      pip install path/to/pymetr

   Or, if your project is hosted on a Git repository, you can install it using:

   .. code-block:: bash

      pip install git+https://github.com/yourusername/pymetr.git

2. **Development Installation**: If you're developing pymetr and want to test changes as you make them, you should install the package in "editable" mode. This allows you to modify the source code and see those changes reflected without having to reinstall the package.

   Navigate to the root directory of your pymetr project and run:

   .. code-block:: bash

      pip install -e .

   This command tells pip to install the package in a way that's symlinked back to your source code, so changes are immediately effective.

Conclusion
----------

Installing the pymetr package is straightforward, whether for use in other projects or for development. The `setup.py` file is crucial for defining package metadata, dependencies, and more. For development purposes, installing in editable mode is highly recommended to facilitate testing and iteration.

For more information on packaging Python projects, refer to the official Python Packaging User Guide: https://packaging.python.org/tutorials/packaging-projects/

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\packaging.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\quickstart.rst
Quick Start Guide
==================

This guide is designed to quickly acquaint you with the foundational elements necessary for instrument communication using the PyVISA library, understanding the IEEE 488.2 standard, and utilizing the SCPI protocol.

PyVISA and Instrument Communication
------------------------------------

PyVISA is a powerful Python library that provides a unified interface for communication with measurement devices across various interfaces, including GPIB, RS232, USB, and Ethernet. As an open-source library, PyVISA simplifies the process of sending commands to and reading responses from your instruments.

- **Documentation and Source Code:** For comprehensive information and to access the source code, please visit the `PyVISA documentation <https://pyvisa.readthedocs.io/en/latest/>`_ and the `PyVISA GitHub page <https://github.com/pyvisa/pyvisa>`_.

IEEE 488.2 Standard
--------------------

The IEEE 488.2 standard outlines codes, formats, protocols, and common commands for programmable instrumentation, ensuring compatibility across devices from different manufacturers that support the IEEE 488 (GPIB) interface.

- **Further Reading:** For a deeper understanding of the IEEE 488.2 standard and its applications, refer to resources such as `Test & Measurement World <https://www.tmworld.com>`_.

SCPI Protocol
--------------

SCPI, or Standard Commands for Programmable Instruments, is a comprehensive standard that specifies a uniform set of commands for controlling and querying test and measurement devices. This ensures interoperability between devices from different manufacturers, provided they adhere to the SCPI protocol.

- **Learning More:** To explore more about the SCPI standard and its implementation, visit the `Wikipedia Page On SCPI <https://en.wikipedia.org/wiki/Standard_Commands_for_Programmable_Instruments>`_.

Getting Started with PyVISA
----------------------------

To begin using PyVISA for instrument communication, you will need to install the library and the necessary backend (NI-VISA or pyvisa-py). Here's a quick rundown to get you started:

1. **Installation:** Install PyVISA using pip:

   .. code-block:: bash

      pip install pyvisa

2. **Identify Your Instrument:** Use PyVISA's resource manager to list connected instruments:

   .. code-block:: python

      import pyvisa
      rm = pyvisa.ResourceManager()
      print(rm.list_resources())

3. **Open a Session:** Choose a resource string from the list and open a session to communicate with the instrument:

   .. code-block:: python

      instrument = rm.open_resource('GPIB0::23::INSTR')
      print(instrument.query('*IDN?'))

This quick start guide aims to provide you with the essential knowledge and steps to embark on instrument communication projects, facilitating a smoother transition into developing sophisticated test and measurement applications.

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\quickstart.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\sphinx.rst
Sphinx Documentation Primer
===========================

This document serves as a quick reference to understand the various field list tags used in Sphinx documentation. These tags are commonly used within Python docstrings to provide structured metadata about the code.

Understanding Field Lists
-------------------------

Field lists are a way to specify and organize metadata in reStructuredText (reST), the markup syntax that Sphinx uses. Here are some of the commonly used field tags:

- ``:param <name>:``: Describes a parameter to a function or a method.
- ``:type <name>:``: Describes the type of a parameter to a function or a method.
- ``:ivar <name>:``: Describes an instance variable (attribute) of a class.
- ``:vartype <name>:``: Describes the type of a class or module variable.
- ``:return:``: Describes what a function or method returns.
- ``:rtype:``: Describes the return type of a function or method.
- ``:raises <exception>:``: Describes the exceptions that a function or method may raise.

Example Usage
-------------

Below is an example of how these field lists might be used in a docstring:

.. code-block:: python

   class MyExampleClass:
       """
       A simple example class to demonstrate Sphinx documentation.

       :ivar my_attribute: Stores an example attribute value.
       :vartype my_attribute: str
       """

       def __init__(self, param1):
           """
           Initializes the class with a specific parameter.

           :param param1: The first parameter required for initialization.
           :type param1: str
           """
           self.my_attribute = param1

       def example_method(self, arg1, arg2):
           """
           This method performs an example operation and returns a result.

           :param arg1: The first argument to the method.
           :type arg1: int
           :param arg2: The second argument to the method.
           :type arg2: float
           :return: The result of processing the arguments.
           :rtype: bool
           :raises ValueError: If the arguments do not meet the criteria.
           """
           # Example method implementation goes here
           return True

When this documentation is built with Sphinx, these field lists will be formatted properly and may be cross-referenced with other parts of the documentation if set up accordingly with the intersphinx extension.

Troubleshooting
---------------

If you encounter any issues during the build process, check the terminal output for error messages. Common issues include syntax errors in reStructuredText files or missing dependencies for Sphinx extensions. Address any reported issues and run `make html` again.

By rebuilding your documentation regularly, you ensure that all team members and users have access to the latest information about your project.

Additional Resources
--------------------

For more in-depth information on Sphinx documentation, visit the official Sphinx documentation site at `Sphinx Documentation <https://www.sphinx-doc.org/en/master/>`_.

Introduction to reStructuredText (ReST)
----------------------------------------

reStructuredText is the default plaintext markup language used by Sphinx. It's designed to be simple and readable, making it easy to create well-structured documentation. To get more familiar with reST and its capabilities, check out the `reStructuredText Primer <https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html>`_ provided by Sphinx.

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\sphinx.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\subsystems.rst
Practical Coding Example: WaveGen Subsystem
-------------------------------------------

This example demonstrates how to use the WaveGen subsystem of an instrument to control waveform output and modulation. Below, we detail the translation of property settings into SCPI commands.

.. code-block:: python

    from pymetr.instrument import Instrument
    from pymetr.subsystem import Subsystem, command_property, command_options
    import logging

    logging.basicConfig(level=logging.INFO)

    class WaveGen(Subsystem):
        """
        Manages the built-in waveform generator (WGEN) of an instrument, controlling waveform output and modulation.
        """

        # Nested enums for clean namespace and easy access
        Functions = command_options('Functions', ['SIN', 'SQU', 'RAMP', 'PULSE', 'NOISE', 'DC'])
        OutputState = command_options('OutputState', ['ON', 'OFF'])

        # Updated property definitions without redundant ":WGEN" prefix
        function = command_property(":FUNC", Functions, "Waveform function")
        frequency = command_property(":FREQ", doc_str="Waveform frequency")
        amplitude = command_property(":VOLT", doc_str="Waveform amplitude")
        output = command_property(":OUTP", OutputState, "Waveform output state")
        offset = command_property(":VOLT:OFFS", doc_str="Waveform offset")

    def __init__(self, parent):
        super().__init__(parent, ":WGEN")

    class MyInstrument(Instrument):
        def __init__(self, resource_string):
            super().__init__(resource_string)
            self.wavegen = WaveGen(self)

    if __name__ == "__main__":
        # We can look for our instrument and select it via command line using the following static function.
        instrument_address = Instrument.select_resources("TCPIP?*INSTR")

        # We need to create an instance of our instrument and give it a name
        inst = MyInstrument(instrument_address)
        
        inst.open() # Open a connection to the instrument through PyVisa

        # Setting properties triggers SCPI write commands:
        inst.wavegen.function = WaveGen.Functions.SIN  # Triggers inst.write(":WGEN:FUNC SIN")
        inst.wavegen.frequency = '1MHz'  # Triggers inst.write(":WGEN:FREQ 1MHz")
        inst.wavegen.amplitude = 2  # Triggers inst.write(":WGEN:VOLT 2")
        inst.wavegen.offset = 0.5  # Triggers inst.write(":WGEN:VOLT:OFFS 0.5")
        inst.wavegen.output = WaveGen.OutputState.ON  # Triggers inst.write(":WGEN:OUTP ON")

        # Accessing properties triggers SCPI query commands:
        print(inst.wavegen.function)  # Triggers inst.query(":WGEN:FUNC?") and returns the function mode
        print(inst.wavegen.frequency)  # Triggers inst.query(":WGEN:FREQ?") and returns the frequency
        print(inst.wavegen.amplitude)  # Triggers inst.query(":WGEN:VOLT?") and returns the amplitude
        print(inst.wavegen.offset)  # Triggers inst.query(":WGEN:VOLT:OFFS?") and returns the offset
        print(inst.wavegen.output)  # Triggers inst.query(":WGEN:OUTP?") and returns the output state

        inst.close() # CLoses the instrument connection

Visual Representation of Property to Command Translation
---------------------------------------------------------

.. graphviz::

    digraph subsystem {
        node [shape=record, fontname=Arial];

        WaveGen [label="{WaveGen Subsystem|+ function (SIN)|+ frequency (1MHz)|+ amplitude (2V)|+ output (ON)|+ offset (0.5)}"];
        SCPI [label="{SCPI Commands|:FUNC SIN|:FREQ 1MHz|:VOLT 2V|:OUTP ON|:VOLT:OFFS 0.5}"];

        WaveGen -> SCPI [label="translates to"];
    }

This Graphviz diagram illustrates how setting properties on the `WaveGen` subsystem translates into specific SCPI commands sent to the instrument.

# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\subsystems.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\subsystem_theory.rst
Understanding Subsystems
========================

Welcome to the deeper dive into our instrumentation framework, focusing on the strategic use of subsystems to streamline instrument control. This section aims to illuminate the theory behind subsystems and their pivotal role in simplifying interaction with test equipment.

Overview
--------

The Subsystem is a foundational concept in our design philosophy, representing a logical component or a distinct functional unit within an instrument. Examples include waveform generators, oscilloscope channels, or power supply modules. Modeling these functions as separate subsystems enables us to encapsulate functionality, thereby simplifying the complex and making the inaccessible readily manageable.

Why Subsystems?
---------------

- **Modularity**: Breaks down complex instruments into manageable units for easier development and upkeep.
- **Reusability**: Allows for development once and deployment everywhere, reducing code duplication across instruments.
- **Extensibility**: Facilitates the addition of new features to existing instruments with minimal disruption.

How It Works
------------

Our approach leverages Python classes to encapsulate each subsystem. We utilize a base `Subsystem` class for common functionalities such as command execution and querying. Specialized subsystems inherit from this base class, tailoring it with specific capabilities.

The alignment with the SCPI command tree is particularly noteworthy. Instruments are often structured in a hierarchical command system, mirroring our subsystem model. This similarity allows our subsystem prefixes to closely match those of the SCPI commands, minimizing code duplication and maximizing efficiency.

.. note:: 

   The power of our model lies in its direct alignment with the SCPI command structure, utilizing subsystem prefixes to streamline command execution. This approach reduces code duplication and leverages modern IDEs for autocompletion, enabling script creation without constant reference to the programming manual.

Example: Setting Oscilloscope Parameters
----------------------------------------

Consider setting parameters on an oscilloscope. Our subsystem approach abstracts the SCPI commands into intuitive property calls, making script development straightforward and IDE-friendly.

.. code-block:: python

    # Assuming `scope` is an instance of an Oscilloscope class with an Acquire subsystem
    scope.acquire.type = Acquire.Type.NORMAL  # Sets acquisition type to normal
    # Behind the scenes: scope.acquire.write("TYPE NORM")

    scope.acquire.sample_rate = 1e6  # Sets sample rate to 1 MSa/s
    # Behind the scenes: scope.acquire.write("SRATe 1e6")

    print(scope.acquire.depth)  # Queries the current acquisition depth
    # Behind the scenes: scope.acquire.query("DEPTh?")

This snippet demonstrates how each property or method call on a subsystem translates into a write or query to the instrument, abstracting the complexity of SCPI commands into user-friendly operations.

Next Steps
----------

The next page delves into the practical implementation of these concepts, showcasing how to create a custom oscilloscope model utilizing our subsystems. This example will highlight the ease of extending the instrument's capabilities and the seamless interaction with its features.


# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\subsystem_theory.rst

# Start of c:\Users\Ryan\Documents\GitHub\pymetr\docs\unit-test.rst
======================================
Unit Testing in Python with unittest
======================================

Introduction
============

Unit testing is an essential aspect of software development that involves testing individual units or components of a software application in isolation from the rest of the application. The primary goal of unit testing is to validate that each unit of the software performs as designed. In Python, the ``unittest`` framework is a powerful tool for creating and running unit tests, providing a rich set of tools for asserting conditions and organizing test code.

Why Unit Testing?
=================

- **Early Bug Detection**: Unit tests help catch bugs early in the development cycle, saving time and effort in later stages.
- **Code Quality**: Writing tests encourages better code design and architecture, leading to more maintainable and robust applications.
- **Refactoring Confidence**: With a comprehensive test suite, developers can refactor code with confidence, ensuring that changes do not break existing functionality.
- **Documentation**: Tests serve as a form of documentation, showing how a particular piece of functionality is expected to be used.

Getting Started with unittest
=============================

The ``unittest`` framework is included with Python's standard library, making it readily available for use without the need for external packages. Here's a quick overview of getting started:

Creating a Test Case
--------------------

A test case is created by subclassing ``unittest.TestCase``. Each method in the class that begins with ``test_`` is a test to be run by the framework.

.. code-block:: python

    import unittest

    class MyTestCase(unittest.TestCase):
        def test_something(self):
            self.assertEqual(True, True)  # An example test

Running Tests
-------------

Tests can be run by calling ``unittest.main()`` if the test file is executed as the main program.

.. code-block:: python

    if __name__ == '__main__':
        unittest.main()

Assertions
----------

The ``unittest`` framework provides a set of assertion methods used to test that conditions are true. Here are some commonly used assertions:

- ``assertEqual(a, b)``: Check that ``a == b``
- ``assertTrue(x)``: Check that ``x`` is true
- ``assertFalse(x)``: Check that ``x`` is false
- ``assertRaises(exc, fun, *args, **kwds)``: Check that an exception is raised when ``fun`` is called with arguments

Example: Testing a Simple Function
----------------------------------

.. code-block:: python

    def add(a, b):
        return a + b

    class TestAddFunction(unittest.TestCase):
        def test_add_integers(self):
            self.assertEqual(add(1, 2), 3)

        def test_add_strings(self):
            self.assertEqual(add('hello ', 'world'), 'hello world')

Mocking External Dependencies
-----------------------------

Sometimes, you need to test code that interacts with external systems or has side effects. The ``unittest.mock`` module allows you to replace parts of your system under test with mock objects and make assertions about how they have been used.

.. code-block:: python

    from unittest.mock import MagicMock
    import mymodule

    class MyTestCase(unittest.TestCase):
        def test_function_with_external_dependency(self):
            mymodule.some_external_dependency = MagicMock()
            # Your test code here
            mymodule.some_external_dependency.assert_called_with('expected argument')

Conclusion
==========

Unit testing is a powerful practice for maintaining high-quality software. The ``unittest`` framework in Python provides a rich set of tools for writing and running tests, ensuring that your code behaves as expected. By integrating unit testing into your development process, you can improve the reliability and maintainability of your projects.


# End of c:\Users\Ryan\Documents\GitHub\pymetr\docs\unit-test.rst

